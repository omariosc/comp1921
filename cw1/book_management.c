/************************************************************************
University of Leeds
School of Computing
COMP1921 - Programming Project
Coursework 1
File: book_management_c

Purpose: 
- Implements functions in book_management.h

Student Name: Omar Choudhry
Student ID: 201398269
Email: sc20osc@leeds.ac.uk
Date Work Commenced: 24.02.2020
*************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "book_management.h"
#include "logic.h"

//-----------------------------------------------------------------------------------------------------------------

// saves the database of books in the specified file
// returns 0 if books were stored correctly, or an error code otherwise
int store_books(FILE* file) {
	file = fopen("books.bin", "wb"); // writes file
	if (file == NULL) return 1; // if file does not exist
  else { // if file exists
    fwrite(&numBooks, sizeof(int), 1, file); // stores number of books
    for (int i = 0; i < numBooks; i++) { // iterates through every book

      // write all details from struct in array to file
      fwrite(&books[i]->id, sizeof(int), 1, file);
      fwrite(books[i]->title, 30*sizeof(char), 1, file);
      fwrite(books[i]->authors, 30*sizeof(char), 1, file);
      fwrite(&books[i]->year, sizeof(int), 1, file);
      fwrite(&books[i]->copies, sizeof(int), 1, file);
    }
		fclose(file); // closes file
		return 0; // function complete
	}
}

// loads the database of books from the specified file
// the file must have been generated by a previous call to store_books()
// returns 0 if books were loaded correctly, or an error code otherwise
int load_books(FILE *file) {
	file = fopen("books.bin", "rb"); // reads file
	if (file == NULL) return 1; // if file does not exist
  else { // if file exists
    for (int i = 0; i < MaxBook; i++) free(books[i]); // frees all existing elements of the array
    fread(&numBooks, sizeof(int), 1, file); // loads number of books from file
    for (int i = 0; i < numBooks; i++) { // iterates through every book in the book array
      books[i] = malloc (sizeof(struct Book)); // allocates memory for the book

      // loads all details about the book
      fread(&books[i]->id, sizeof(int), 1, file);
      fread(books[i]->title, 30*sizeof(char), 1, file);
      fread(books[i]->authors, 30*sizeof(char), 1, file);
      fread(&books[i]->year, sizeof(int), 1, file);
      fread(&books[i]->copies, sizeof(int), 1, file);
    }
		fclose(file); // closes file
		return 0; // function complete
	}
}

// adds a book to the ones available to the library
// returns 0 if the book could be added, or an error code otherwise
int add_book(struct Book book) {
  books[numBooks] = malloc (sizeof(struct Book));
  books[numBooks]->id = book.id;
  strcpy(books[numBooks]->title, book.title);
  strcpy(books[numBooks]->authors, book.authors);
  books[numBooks]->year = book.year;
  books[numBooks]->copies = book.copies;
  numBooks++;
  return 0;
}

// removes a book from the library
// returns 0 if the book could be successfully removed, or an error code otherwise.
int remove_book(struct Book book) {
  for (int i = 0; i < numBooks; i++) { // iterates through all books
    if (book.id == books[i]->id) { // if ID matches
      for (int j = i; j < numBooks - 1; j++) { // iterates through remaining books
        // assigns all inputs and ID
        strcpy(books[j]->title, books[j+1]->title);
        strcpy(books[j]->authors, books[j+1]->authors);
        books[j]->year = books[j+1]->year;
        books[j]->copies = books[j+1]->copies;

        // changes ID for books on loan
        for (int k = 0; k < numLoans; k++) { // iterates through loans
          if(loans[k]->bookid == books[j]->id) { // if book exists with same ID
            loans[k]->bookid--; // decrements book ID on loan
          }
        }
      }
      numBooks--; // reduces total number of books
      return 0; // successful removed
    }    
  }
  return -99; // error code 
}


// finds books with a given title.
// returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the
// provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
// array is the null pointer.
struct BookArray find_book_by_title (const char *title) {
  struct BookArray bookTitleArray; // creates  the BookArray struct containing books with same title
  bookTitleArray.length = 0; // sets intial length of array to 0
  for (int i = 0; i < numBooks; i++) { // iterate through all books
    if (strcmp(books[i]->title, title) == 0) { // if book found with same title
      bookTitleArray.array[bookTitleArray.length] = *(books[i]); // assigns book from array into struct BookArray
      bookTitleArray.length++;
      break; // ends loop
    }
  }
  return bookTitleArray; // returns struct containing books with same title
}

// finds books with the given authors.
// returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the
// provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
// array is the null pointer.
struct BookArray find_book_by_author (const char *author) {
  struct BookArray bookAuthorArray; // creates  the BookArray struct containing books with same authors
  bookAuthorArray.length = 0; // sets intial length of array to 0
  for (int i = 0; i < numBooks; i++) { // iterate through all books
    if (strcmp(books[i]->authors, author) == 0) { // if book found with same author
      bookAuthorArray.array[bookAuthorArray.length] = *(books[i]); // assigns book from array into struct BookArray
      bookAuthorArray.length++;
      break; // ends loop
    }
  }
  return bookAuthorArray; // returns struct containing books with same author
}

// finds books published in the given year.
// returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the
// provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
// array is the null pointer.
struct BookArray find_book_by_year (unsigned int year) {
  struct BookArray bookYearArray; // creates the BookArray struct containing books with same year
  bookYearArray.length = 0; // sets intial length of array to 0
  for (int i = 0; i < numBooks; i++) { // iterate through all books
    if (books[i]->year == year) { // if book found with same year
      bookYearArray.array[bookYearArray.length] = *(books[i]); // assigns book from array into struct BookArray
      bookYearArray.length++;
      break; // ends loop
    }
  }
  return bookYearArray; // returns struct containing books with same year
}

//-----------------------------------------------------------------------------------------------------------------